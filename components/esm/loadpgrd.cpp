#include "loadpgrd.hpp"

#include "esmreader.hpp"
#include "esmwriter.hpp"
#include "defs.hpp"

#include <iostream>
#ifdef _WIN32
#include <Windows.h>
#else
void inline OutputDebugString(char *c_string) { std::cout << c_string; };
void inline OutputDebugString(const char *c_string) { std::cout << c_string; };
#endif

namespace ESM
{
    unsigned int Pathgrid::sRecordId = REC_PGRD;

    Pathgrid::Point& Pathgrid::Point::operator=(const float rhs[3])
    {
        mX = static_cast<int>(rhs[0]);
        mY = static_cast<int>(rhs[1]);
        mZ = static_cast<int>(rhs[2]);
        mAutogenerated = 0;
        mConnectionNum = 0;
        mUnknown = 0;
        return *this;
    }
    Pathgrid::Point::Point(const float rhs[3])
    : mX(static_cast<int>(rhs[0])),
      mY(static_cast<int>(rhs[1])),
      mZ(static_cast<int>(rhs[2])),
      mAutogenerated(0),
      mConnectionNum(0),
      mUnknown(0)
    {
    }
    Pathgrid::Point::Point():mX(0),mY(0),mZ(0),mAutogenerated(0),
                             mConnectionNum(0),mUnknown(0)
    {
    }

    void Pathgrid::load(ESMReader &esm, bool &isDeleted)
    {
        isDeleted = false;

        mPoints.clear();
        mEdges.clear();

        // keep track of total connections so we can reserve edge vector size
        int edgeCount = 0;

        bool hasData = false;
        while (esm.hasMoreSubs())
        {
            esm.getSubName();
            switch (esm.retSubName().intval)
            {
                case ESM::SREC_NAME:
                    mCell = esm.getHString();
                    break;
                case ESM::FourCC<'D','A','T','A'>::value:
                    esm.getHT(mData, 12);
                    hasData = true;
                    break;
                case ESM::FourCC<'P','G','R','P'>::value:
                {
                    esm.getSubHeader();
                    int size = esm.getSubSize();
                    // Check that the sizes match up. Size = 16 * s2 (path points)
                    if (size != static_cast<int> (sizeof(Point) * mData.mS2))
                        esm.fail("Path point subrecord size mismatch");
                    else
                    {
                        int pointCount = mData.mS2;
                        mPoints.reserve(pointCount);
                        for (int i = 0; i < pointCount; ++i)
                        {
                            Point p;
                            esm.getExact(&p, sizeof(Point));
                            mPoints.push_back(p);
                            edgeCount += p.mConnectionNum;
                        }
                    }
                    break;
                }
                case ESM::FourCC<'P','G','R','C'>::value:
                {
                    esm.getSubHeader();
                    int size = esm.getSubSize();
                    if (size % sizeof(int) != 0)
                        esm.fail("PGRC size not a multiple of 4");
                    else
                    {
                        int rawConnNum = size / sizeof(int);
                        std::vector<int> rawConnections;
                        rawConnections.reserve(rawConnNum);
                        for (int i = 0; i < rawConnNum; ++i)
                        {
                            int currentValue;
                            esm.getT(currentValue);
                            rawConnections.push_back(currentValue);
                        }

                        std::vector<int>::const_iterator rawIt = rawConnections.begin();
                        int pointIndex = 0;
                        mEdges.reserve(edgeCount);
                        for(PointList::const_iterator it = mPoints.begin(); it != mPoints.end(); ++it, ++pointIndex)
                        {
                            unsigned char connectionNum = (*it).mConnectionNum;
                            for (int i = 0; i < connectionNum; ++i) {
                                Edge edge;
                                edge.mV0 = pointIndex;
                                edge.mV1 = *rawIt;
                                ++rawIt;
                                mEdges.push_back(edge);
                            }
                        }
                    }
                    break;
                }
                case ESM::SREC_DELE:
                    esm.skipHSub();
                    isDeleted = true;
                    break;
                default:
                    esm.fail("Unknown subrecord");
                    break;
            }
        }

        if (!hasData)
            esm.fail("Missing DATA subrecord");
    }

    void Pathgrid::save(ESMWriter &esm, bool isDeleted) const
    {
        // Correct connection count and sort edges by point
        // Can probably be optimized
        PointList correctedPoints = mPoints;
        std::vector<int> sortedEdges;

        sortedEdges.reserve(mEdges.size());

        for (size_t point = 0; point < correctedPoints.size(); ++point)
        {
            correctedPoints[point].mConnectionNum = 0;

            for (EdgeList::const_iterator it = mEdges.begin(); it != mEdges.end(); ++it)
            {
                if (static_cast<size_t>(it->mV0) == point)
                {
                    sortedEdges.push_back(it->mV1);
                    ++correctedPoints[point].mConnectionNum;
                }
            }
        }

        // Save
        esm.writeHNCString("NAME", mCell);
        esm.writeHNT("DATA", mData, 12);

        if (isDeleted)
        {
            esm.writeHNCString("DELE", "");
            return;
        }

        if (!correctedPoints.empty())
        {
            esm.startSubRecord("PGRP");
            for (PointList::const_iterator it = correctedPoints.begin(); it != correctedPoints.end(); ++it)
            {
                esm.writeT(*it);
            }
            esm.endRecord("PGRP");
        }

        if (!sortedEdges.empty())
        {
            esm.startSubRecord("PGRC");
            for (std::vector<int>::const_iterator it = sortedEdges.begin(); it != sortedEdges.end(); ++it)
            {
                esm.writeT(*it);
            }
            esm.endRecord("PGRC");
        }
    }

	void Pathgrid::exportSubCellTES4(ESMWriter & esm, int subCellX, int subCellY, bool isInterior) const
	{
		// must split pathgrid into 4 subcells and then count only nodes for this subcell
		// intra-subcell node edges remain unchanged,
		// inter-subcell node edges must be changed to extra-subcell edge types
		uint16_t numNodes = 0;
		int baseX = 0, baseY = 0;
		if (isInterior == false)
		{
			baseX = subCellX - abs(subCellX % 2);
			baseY = subCellY - abs(subCellY % 2);
		}

		// list of subcell nodes
		std::vector<Point> nodesIncluded;
		std::vector<Point> nodesExcluded;
		std::map<int, int> oldIndexToNewIndex;
		std::map<int, std::vector<int> > nodeConnectionsMap;
		std::map<int, std::vector<int> > nodeExternalConnectionsMap;

		// iterate through original list...
		int nodeIndex=0;
		for (auto nodeIter = mPoints.begin(); nodeIter != mPoints.end(); nodeIter++, nodeIndex++)
		{
			bool inThisSubCell=false;

			if (isInterior == false)
			{
				int CellXofNode = nodeIter->mX / 4096;
				if (nodeIter->mX < 0)
				{
					CellXofNode--;
//					throw std::runtime_error("PathGrid ERROR: negative value for node position");
					OutputDebugString("PathGrid ERROR: negative value for node position\n");
				}
				int CellYofNode = nodeIter->mY / 4096;
				if (nodeIter->mY < 0) 
				{
					CellYofNode--;
//					throw std::runtime_error("PathGrid ERROR: negative value for node position");
					OutputDebugString("PathGrid ERROR: negative value for node position\n");
				}
				if ( CellXofNode == (subCellX % 2) && CellYofNode == (subCellY % 2) )
					inThisSubCell = true;
			}
			else
			{
				inThisSubCell = true;
			}

			// sort into this or other subcell
			if (inThisSubCell)
			{
				nodesIncluded.push_back(*nodeIter);
				// map old index to inclusion index
				oldIndexToNewIndex[nodeIndex] = nodesIncluded.size()-1;
			}
			else
			{
				nodesExcluded.push_back(*nodeIter);
				// map old index to exlusion (index+1)*-1
				oldIndexToNewIndex[nodeIndex] = -1*(nodesExcluded.size());
			}
		}

		// iterate through edge list and populate connection map
		for (auto edgeIter = mEdges.begin(); edgeIter != mEdges.end(); edgeIter++)
		{
			// always compare and make decisions based on mV0
			int currentOldIndex = edgeIter->mV0;
			// sanity check
			if (oldIndexToNewIndex.find(currentOldIndex) != oldIndexToNewIndex.end() )
			{
				int activeNewIndex = oldIndexToNewIndex[currentOldIndex];
				if (activeNewIndex >= 0)
				{
					// add to connectionsMap
					int activeConnectionIndex = oldIndexToNewIndex[edgeIter->mV1];
					if (activeConnectionIndex >= 0)
					{
						// inner-subcell
						std::vector<int>& nodeList = nodeConnectionsMap[activeNewIndex];
						nodeList.push_back(activeConnectionIndex);
					}
					else
					{
						// extra-subcell
						std::vector<int>& nodeList = nodeExternalConnectionsMap[activeNewIndex];
						nodeList.push_back( (-1*activeConnectionIndex) - 1 );
					}
				}
				else
				{
					// skip excluded mV0 node
					continue;
				}
			}

		}

		esm.startSubRecordTES4("DATA");
		numNodes = nodesIncluded.size();
		esm.writeT<uint16_t>(numNodes);
		esm.endSubRecordTES4("DATA");

		// write node list
		if (nodesIncluded.size() > 0)
		{
			esm.startSubRecordTES4("PGRP");
			nodeIndex = 0;
			for (auto nodeIter = nodesIncluded.begin(); nodeIter != nodesIncluded.end(); nodeIter++, nodeIndex++)
			{
				float x, y, z;
				if (isInterior)
				{
					x = nodeIter->mX;
					y = nodeIter->mY;
					z = nodeIter->mZ + 10;
				}
				else
				{
					x = (4096 * baseX) + nodeIter->mX;
					y = (4096 * baseY) + nodeIter->mY;
					z = nodeIter->mZ + 10;
				}
				if (nodeIter->mAutogenerated)
				{
					z = ((int)z % 2) == 0 ? z : z + 1;
				}
				else
				{
					z = ((int)z % 2) != 0 ? z : z + 1;
				}
				esm.writeT<float>(x);
				esm.writeT<float>(y);
				esm.writeT<float>(z);
				uint8_t numConnections = nodeConnectionsMap[nodeIndex].size();
				esm.writeT<uint8_t>(numConnections);
				esm.writeT<uint8_t>(0);
				esm.writeT<uint8_t>(0);
				esm.writeT<uint8_t>(0);
			}
			esm.endSubRecordTES4("PGRP");
		}

		// write interior connection list
		if (nodeConnectionsMap.size() > 0)
		{
			esm.startSubRecordTES4("PGRR");
			for (nodeIndex = 0; nodeIndex < nodesIncluded.size(); nodeIndex++)
			{
				std::vector<int>& nodeIndexList = nodeConnectionsMap[nodeIndex];
				for (auto indexIter = nodeIndexList.begin(); indexIter != nodeIndexList.end(); indexIter++)
				{
					uint16_t connectionIndex = *indexIter;
					esm.writeT<uint16_t>(connectionIndex);
				}
			}
			esm.endSubRecordTES4("PGRR");
		} // PGRR

		// write exterior connection list
		if (nodeExternalConnectionsMap.size() > 0)
		{
			esm.startSubRecordTES4("PGRI");
			for (nodeIndex = 0; nodeIndex < nodesIncluded.size(); nodeIndex++)
			{
				std::vector<int>& extnodeIndexList = nodeExternalConnectionsMap[nodeIndex];
				if (extnodeIndexList.size() > 0)
				{
					for (auto indexIter = extnodeIndexList.begin(); indexIter != extnodeIndexList.end(); indexIter++)
					{
						int extConnectionIndex = *indexIter;
						if (extConnectionIndex < nodesExcluded.size())
						{
							Point& extNode = nodesExcluded[extConnectionIndex];
							float x = (baseX * 4096) + extNode.mX;
							float y = (baseY * 4096) + extNode.mY;
							float z = extNode.mZ + 10;
							if (extNode.mAutogenerated)
							{
								z = ((int)z % 2) == 0 ? z : z + 1;
							}
							else
							{
								z = ((int)z % 2) != 0 ? z : z + 1;
							}
							esm.writeT<uint16_t>(nodeIndex);
							esm.writeT<uint16_t>(0); // unused
							esm.writeT<float>(x);
							esm.writeT<float>(y);
							esm.writeT<float>(z);
						}
					}
				}
			}
			esm.endSubRecordTES4("PGRI");
		} // PGRI

	}

    void Pathgrid::blank()
    {
        mCell.clear();
        mData.mX = 0;
        mData.mY = 0;
        mData.mS1 = 0;
        mData.mS2 = 0;
        mPoints.clear();
        mEdges.clear();
    }
}
